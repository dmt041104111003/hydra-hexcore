import * as CardanoWasm from '@emurgo/cardano-serialization-lib-nodejs';
import { mnemonicToEntropy } from 'bip39';

// Purpose derivation (See BIP43)
export enum Purpose {
  CIP1852 = 1852, // see CIP 1852
}

// Cardano coin type (SLIP 44)
export enum CoinTypes {
  CARDANO = 1815,
}

export enum ChainDerivation {
  EXTERNAL = 0, // from BIP44
  INTERNAL = 1, // from BIP44
  CHIMERIC = 2, // from CIP1852
}

function harden(num: number): number {
  return num | 0x80000000;
}

export function getRootKeyByMnemonic(mnemonic: string): CardanoWasm.Bip32PrivateKey {
  const entropy = mnemonicToEntropy(mnemonic);
  const rootKey = CardanoWasm.Bip32PrivateKey.from_bip39_entropy(
    Buffer.from(entropy, 'hex'),
    Buffer.from(''),
  );
  return rootKey;
}

/**
 *
 * @param account : getCip1852Account
 * @returns path `1852'/1815'/0'/0/0`
 */
export function getBaseAddressFromMnemonic(mnemonic: string): CardanoWasm.BaseAddress {
  const rootKey = getRootKeyByMnemonic(mnemonic);
  // Derive the key using path 1852'/1815'/0'/0/0
  const accountKey = rootKey
    .derive(1852 | 0x80000000) // Purpose: 1852'
    .derive(1815 | 0x80000000) // Coin type: 1815' (ADA)
    .derive(0 | 0x80000000) // Account index: 0'
    .derive(0) // External chain: 0
    .derive(0); // Address index: 0
  const publicKey = accountKey.to_public();
  const network = CardanoWasm.NetworkInfo.testnet_preprod(); // Use NetworkInfo.testnet() for testnet

  // Deriving the staking private key using the path 1852'/1815'/0'/2/0
  const stakingPrivateKey = rootKey
    .derive(1852 | 0x80000000) // Purpose: 1852'
    .derive(1815 | 0x80000000) // Coin type: 1815' (ADA)
    .derive(0 | 0x80000000) // Account index: 0'
    .derive(2) // Internal chain: 2 (for staking)
    .derive(0); // Staking key index: 0

  const baseAddress = CardanoWasm.BaseAddress.new(
    network.network_id(),
    CardanoWasm.Credential.from_keyhash(publicKey.to_raw_key().hash()),
    CardanoWasm.Credential.from_keyhash(stakingPrivateKey.to_public().to_raw_key().hash()),
  );
  return baseAddress;
}

/**
 *
 * @param mnemonic
 * @returns Acccount 1852' / 1815' / 0'
 */
export function getCip1852Account(mnemonic: string): CardanoWasm.Bip32PrivateKey {
  const rootKey = getRootKeyByMnemonic(mnemonic);
  return rootKey
    .derive(harden(Purpose.CIP1852))
    .derive(harden(CoinTypes.CARDANO))
    .derive(harden(0)); // account #0
}

export function getPrivateKeyByMnemonic(mnemonic: string): CardanoWasm.Bip32PrivateKey {
  const account = getCip1852Account(mnemonic);
  const prvKey = account.derive(ChainDerivation.EXTERNAL).derive(0);
  return prvKey;
}

export class PaymentSigningKey {
  public type: string;
  public description: string;
  public cborHex: string;
  /**
   * @param extendedKey : 64 bytes extended key
   */
  constructor(extendedKey: string) {
    if (extendedKey.length !== 64) {
      throw new Error('Invalid extended key');
    }
    this.type = 'PaymentSigningKeyShelley_ed25519';
    this.description = 'Generated by Hexcore';
    this.cborHex = `5820${extendedKey}`;
  }

  toJSON(replacer?: any, space?: string | number) {
    return JSON.stringify(
      {
        type: this.type,
        description: this.description,
        cborHex: this.cborHex,
      },
      replacer,
      space,
    );
  }
}
export function getSigningKeyFromMnemonic(mnemonic: string): PaymentSigningKey {
  const rootKey = getRootKeyByMnemonic(mnemonic);
  const paymentKey = rootKey // Derive the key using path 1852'/1815'/0'/0/0
    .derive(Purpose.CIP1852 | 0x80000000)
    .derive(CoinTypes.CARDANO | 0x80000000)
    .derive(0 | 0x80000000) // Account index: 0'
    .derive(ChainDerivation.EXTERNAL) //
    .derive(0); // Address index: 0
  const privateKey = paymentKey.to_raw_key();
  const extendedKey = privateKey.to_hex().slice(4, 68);
  return new PaymentSigningKey(extendedKey);
}

export class PaymentVerificationKey {
  public type: string;
  public description: string;
  public cborHex: string;

  constructor(skey: string | PaymentSigningKey) {
    let pvkey: CardanoWasm.PublicKey;
    if (skey instanceof PaymentSigningKey) {
      const pskey = CardanoWasm.PrivateKey.from_hex(skey.cborHex.slice(4));
      pvkey = pskey.to_public();
    } else {
      if (skey.length !== 68) {
        throw new Error('Invalid extended key');
      }
      const pskey = CardanoWasm.PrivateKey.from_hex(skey.slice(4));
      pvkey = pskey.to_public();
    }
    this.type = 'PaymentVerificationKeyShelley_ed25519';
    this.description = 'Generated by Hexcore';
    this.cborHex = `5820${pvkey.to_hex()}`;
  }

  toJSON(replacer?: any, space?: string | number) {
    return JSON.stringify(
      {
        type: this.type,
        description: this.description,
        cborHex: this.cborHex,
      },
      replacer,
      space,
    );
  }
}
export function getVerificationKeyFromSigningKey(skey: PaymentSigningKey): PaymentVerificationKey {
  return new PaymentVerificationKey(skey);
}
